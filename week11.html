<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 11 - 進階字串處理 | C語言程式設計</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(to bottom, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
            line-height: 1.7;
        }
        .container { max-width: 1000px; margin: 0 auto; padding: 20px; }
        .nav {
            background: white;
            padding: 15px 25px;
            border-radius: 8px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .nav a {
            color: #3498db;
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .nav a:hover { background: #3498db; color: white; }
        header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 50px 40px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        header h1 { font-size: 2.5em; margin-bottom: 10px; }
        header .subtitle { font-size: 1.1em; opacity: 0.9; }
        .content {
            background: white;
            border-radius: 8px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .content h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }
        .content h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 30px 0 15px 0;
        }
        .content h4 {
            color: #546e7a;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.95em;
            overflow-x: auto;
            margin: 20px 0;
            line-height: 1.6;
        }
        .note-box {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .tip-box {
            background: #e8f5e9;
            border-left: 4px solid #66bb6a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .warning-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .danger-box {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .exercise-section {
            background: #f8f9fa;
            border: 2px solid #3498db;
            padding: 30px;
            margin: 30px 0;
            border-radius: 8px;
        }
        ul, ol { margin-left: 30px; margin-top: 10px; }
        li { margin: 8px 0; }
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        .btn {
            display: inline-block;
            padding: 12px 30px;
            background: #3498db;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .btn-secondary { background: #95a5a6; }
        .btn-secondary:hover { background: #7f8c8d; }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav">
            <a href="week10.html">← Week 10</a>
            <span style="color: #7f8c8d; font-weight: 600;">Week 11 / 16</span>
            <a href="week12.html">Week 12 →</a>
        </div>

        <header>
            <h1>Week 11 - 進階字串處理</h1>
            <div class="subtitle">學習目標：掌握字串解析、格式化與搜尋技巧</div>
        </header>

        <div class="content">
            <h2>本週學習內容</h2>
            <ul>
                <li>字串分割與解析技巧</li>
                <li>字串格式化與驗證</li>
                <li>字串搜尋演算法</li>
                <li>字串轉換與編碼</li>
                <li>正規表示法基礎</li>
                <li>多位元組字串處理</li>
                <li>實務應用與效能優化</li>
            </ul>
        </div>

        <div class="content">
            <h2>1. 字串分割與解析</h2>
            
            <h3>1.1 使用 strtok() 分割字串</h3>
            <p>strtok() 是標準函式庫提供的字串分割函數，可依據指定的分隔符號將字串切割成多個子字串。</p>
            
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    // 注意：strtok 會修改原字串，所以使用可修改的陣列
    char str[] = "apple,banana,cherry,date";
    char *token;
    
    printf("原始字串：%s\n\n", str);
    
    // 第一次呼叫 strtok，傳入字串指標
    token = strtok(str, ",");
    
    printf("分割結果：\n");
    while (token != NULL) {
        printf("  %s\n", token);
        // 後續呼叫傳入 NULL
        token = strtok(NULL, ",");
    }
    
    return 0;
}</pre>
            </div>

            <div class="warning-box">
                <strong>strtok() 的重要特性：</strong>
                <ul>
                    <li>會修改原始字串（將分隔符號替換為 '\0'）</li>
                    <li>不是執行緒安全的（使用靜態變數）</li>
                    <li>無法處理空白 token</li>
                    <li>替代方案：strtok_r()（可重入版本）</li>
                </ul>
            </div>

            <h3>1.2 自製安全的字串分割函數</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_TOKENS 100

// 安全的字串分割函數
int splitString(const char *str, char delimiter, char *tokens[], int maxTokens) {
    int count = 0;
    const char *start = str;
    const char *end;
    
    while (*start && count < maxTokens) {
        // 跳過開頭的分隔符號
        while (*start == delimiter) {
            start++;
        }
        
        if (*start == '\0') break;
        
        // 尋找下一個分隔符號
        end = start;
        while (*end && *end != delimiter) {
            end++;
        }
        
        // 複製 token
        int len = end - start;
        tokens[count] = (char*)malloc(len + 1);
        strncpy(tokens[count], start, len);
        tokens[count][len] = '\0';
        count++;
        
        start = end;
    }
    
    return count;
}

// 釋放記憶體
void freeTokens(char *tokens[], int count) {
    for (int i = 0; i < count; i++) {
        free(tokens[i]);
    }
}

int main() {
    const char *str = "apple,banana,cherry,date,elderberry";
    char *tokens[MAX_TOKENS];
    
    int count = splitString(str, ',', tokens, MAX_TOKENS);
    
    printf("分割成 %d 個部分：\n", count);
    for (int i = 0; i < count; i++) {
        printf("  [%d] %s\n", i, tokens[i]);
    }
    
    // 釋放記憶體
    freeTokens(tokens, count);
    
    return 0;
}</pre>
            </div>

            <h3>1.3 CSV 解析器</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_FIELDS 20
#define MAX_LINE 1024

// 解析 CSV 行（處理引號內的逗號）
int parseCSVLine(char *line, char *fields[], int maxFields) {
    int count = 0;
    char *ptr = line;
    int inQuotes = 0;
    char *fieldStart = ptr;
    
    while (*ptr && count < maxFields) {
        if (*ptr == '"') {
            inQuotes = !inQuotes;
        } else if (*ptr == ',' && !inQuotes) {
            // 找到分隔符號
            *ptr = '\0';
            
            // 移除引號
            if (*fieldStart == '"') {
                fieldStart++;
                if (*(ptr - 1) == '"') {
                    *(ptr - 1) = '\0';
                }
            }
            
            fields[count++] = strdup(fieldStart);
            fieldStart = ptr + 1;
        }
        ptr++;
    }
    
    // 處理最後一個欄位
    if (*fieldStart && count < maxFields) {
        if (*fieldStart == '"') {
            fieldStart++;
            ptr = fieldStart + strlen(fieldStart) - 1;
            if (*ptr == '"') {
                *ptr = '\0';
            }
        }
        fields[count++] = strdup(fieldStart);
    }
    
    return count;
}

int main() {
    char line[] = "John Doe,\"123 Main St, Apt 4\",30,Engineer";
    char *fields[MAX_FIELDS];
    
    int count = parseCSVLine(line, fields, MAX_FIELDS);
    
    printf("解析 CSV 行：\n");
    for (int i = 0; i < count; i++) {
        printf("  欄位 %d: %s\n", i + 1, fields[i]);
        free(fields[i]);
    }
    
    return 0;
}</pre>
            </div>
        </div>

        <div class="content">
            <h2>2. 字串格式化與驗證</h2>
            
            <h3>2.1 字串格式化</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

// 轉換為大寫
void toUpper(char *str) {
    while (*str) {
        *str = toupper(*str);
        str++;
    }
}

// 轉換為小寫
void toLower(char *str) {
    while (*str) {
        *str = tolower(*str);
        str++;
    }
}

// 首字母大寫
void capitalize(char *str) {
    int newWord = 1;
    
    while (*str) {
        if (isspace(*str)) {
            newWord = 1;
        } else if (newWord) {
            *str = toupper(*str);
            newWord = 0;
        } else {
            *str = tolower(*str);
        }
        str++;
    }
}

// 移除前後空白
char* trim(char *str) {
    char *end;
    
    // 移除前面的空白
    while (isspace((unsigned char)*str)) {
        str++;
    }
    
    if (*str == 0) {
        return str;
    }
    
    // 移除後面的空白
    end = str + strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end)) {
        end--;
    }
    
    *(end + 1) = '\0';
    
    return str;
}

int main() {
    char str1[] = "hello world";
    char str2[] = "HELLO WORLD";
    char str3[] = "hello world from c programming";
    char str4[] = "   trim me   ";
    
    toUpper(str1);
    printf("大寫：%s\n", str1);
    
    toLower(str2);
    printf("小寫：%s\n", str2);
    
    capitalize(str3);
    printf("首字母大寫：%s\n", str3);
    
    char *trimmed = trim(str4);
    printf("修剪空白：'%s'\n", trimmed);
    
    return 0;
}</pre>
            </div>

            <h3>2.2 字串驗證</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

// 驗證電子郵件格式
int isValidEmail(const char *email) {
    const char *at = strchr(email, '@');
    const char *dot;
    
    // 必須包含 @
    if (at == NULL) return 0;
    
    // @ 不能在開頭
    if (at == email) return 0;
    
    // @ 後面必須有 .
    dot = strchr(at, '.');
    if (dot == NULL) return 0;
    
    // . 不能緊接在 @ 後面
    if (dot == at + 1) return 0;
    
    // . 後面必須有字元
    if (*(dot + 1) == '\0') return 0;
    
    return 1;
}

// 驗證手機號碼（台灣格式：09XX-XXXXXX）
int isValidPhone(const char *phone) {
    // 長度檢查
    if (strlen(phone) != 11) return 0;
    
    // 格式檢查：09XX-XXXXXX
    if (phone[0] != '0' || phone[1] != '9') return 0;
    if (phone[4] != '-') return 0;
    
    // 數字檢查
    for (int i = 0; i < 11; i++) {
        if (i == 4) continue;  // 跳過 '-'
        if (!isdigit(phone[i])) return 0;
    }
    
    return 1;
}

// 驗證身分證字號（台灣格式）
int isValidTaiwanID(const char *id) {
    if (strlen(id) != 10) return 0;
    
    // 第一個字元必須是英文字母
    if (!isalpha(id[0])) return 0;
    
    // 第二個字元必須是 1 或 2
    if (id[1] != '1' && id[1] != '2') return 0;
    
    // 其他字元必須是數字
    for (int i = 2; i < 10; i++) {
        if (!isdigit(id[i])) return 0;
    }
    
    // 檢查碼驗證（簡化版）
    return 1;
}

// 驗證密碼強度
int checkPasswordStrength(const char *password) {
    int hasUpper = 0, hasLower = 0, hasDigit = 0, hasSpecial = 0;
    int len = strlen(password);
    
    if (len < 8) return 0;  // 太短
    
    for (int i = 0; i < len; i++) {
        if (isupper(password[i])) hasUpper = 1;
        else if (islower(password[i])) hasLower = 1;
        else if (isdigit(password[i])) hasDigit = 1;
        else hasSpecial = 1;
    }
    
    int score = hasUpper + hasLower + hasDigit + hasSpecial;
    
    // 1: 弱, 2: 中, 3: 強, 4: 很強
    return score;
}

int main() {
    // 測試電子郵件
    printf("電子郵件驗證：\n");
    printf("  test@example.com: %s\n", 
           isValidEmail("test@example.com") ? "有效" : "無效");
    printf("  invalid.email: %s\n", 
           isValidEmail("invalid.email") ? "有效" : "無效");
    
    // 測試手機號碼
    printf("\n手機號碼驗證：\n");
    printf("  0912-345678: %s\n", 
           isValidPhone("0912-345678") ? "有效" : "無效");
    printf("  0812-345678: %s\n", 
           isValidPhone("0812-345678") ? "有效" : "無效");
    
    // 測試身分證字號
    printf("\n身分證字號驗證：\n");
    printf("  A123456789: %s\n", 
           isValidTaiwanID("A123456789") ? "有效" : "無效");
    printf("  12345678: %s\n", 
           isValidTaiwanID("12345678") ? "有效" : "無效");
    
    // 測試密碼強度
    printf("\n密碼強度檢查：\n");
    printf("  password: 強度 %d\n", checkPasswordStrength("password"));
    printf("  Pass123: 強度 %d\n", checkPasswordStrength("Pass123"));
    printf("  P@ssw0rd: 強度 %d\n", checkPasswordStrength("P@ssw0rd"));
    
    return 0;
}</pre>
            </div>
        </div>

        <div class="content">
            <h2>3. 字串搜尋演算法</h2>
            
            <h3>3.1 基本字串搜尋</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// 使用標準函式庫搜尋
void basicSearch() {
    const char *text = "Hello World, Welcome to C Programming";
    const char *pattern = "World";
    
    char *result = strstr(text, pattern);
    
    if (result != NULL) {
        printf("找到 '%s' 在位置：%ld\n", pattern, result - text);
    } else {
        printf("找不到 '%s'\n", pattern);
    }
}

// 搜尋所有出現位置
void findAllOccurrences(const char *text, const char *pattern) {
    const char *ptr = text;
    int position = 0;
    int count = 0;
    
    printf("搜尋 '%s' 在文字中的所有位置：\n", pattern);
    
    while ((ptr = strstr(ptr, pattern)) != NULL) {
        position = ptr - text;
        printf("  位置 %d\n", position);
        ptr += strlen(pattern);
        count++;
    }
    
    printf("總共找到 %d 次\n", count);
}

int main() {
    basicSearch();
    
    printf("\n");
    const char *text = "apple banana apple cherry apple date";
    findAllOccurrences(text, "apple");
    
    return 0;
}</pre>
            </div>

            <h3>3.2 暴力搜尋法（Brute Force）</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// 暴力搜尋實作
int bruteForceSearch(const char *text, const char *pattern) {
    int textLen = strlen(text);
    int patternLen = strlen(pattern);
    
    for (int i = 0; i <= textLen - patternLen; i++) {
        int j;
        
        for (j = 0; j < patternLen; j++) {
            if (text[i + j] != pattern[j]) {
                break;
            }
        }
        
        if (j == patternLen) {
            return i;  // 找到，返回位置
        }
    }
    
    return -1;  // 找不到
}

int main() {
    const char *text = "AABAACAADAABAAABAA";
    const char *pattern = "AABA";
    
    int position = bruteForceSearch(text, pattern);
    
    if (position != -1) {
        printf("找到 '%s' 在位置：%d\n", pattern, position);
    } else {
        printf("找不到 '%s'\n", pattern);
    }
    
    return 0;
}</pre>
            </div>

            <h3>3.3 KMP 演算法（Knuth-Morris-Pratt）</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

// 建立失敗函數（failure function）
void computeLPSArray(const char *pattern, int patternLen, int *lps) {
    int len = 0;
    lps[0] = 0;
    int i = 1;
    
    while (i < patternLen) {
        if (pattern[i] == pattern[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
}

// KMP 搜尋
int KMPSearch(const char *text, const char *pattern) {
    int textLen = strlen(text);
    int patternLen = strlen(pattern);
    
    int *lps = (int*)malloc(sizeof(int) * patternLen);
    computeLPSArray(pattern, patternLen, lps);
    
    int i = 0;  // text 的索引
    int j = 0;  // pattern 的索引
    
    while (i < textLen) {
        if (pattern[j] == text[i]) {
            j++;
            i++;
        }
        
        if (j == patternLen) {
            free(lps);
            return i - j;  // 找到，返回位置
        } else if (i < textLen && pattern[j] != text[i]) {
            if (j != 0) {
                j = lps[j - 1];
            } else {
                i++;
            }
        }
    }
    
    free(lps);
    return -1;  // 找不到
}

int main() {
    const char *text = "ABABDABACDABABCABAB";
    const char *pattern = "ABABCABAB";
    
    int position = KMPSearch(text, pattern);
    
    if (position != -1) {
        printf("KMP 找到 '%s' 在位置：%d\n", pattern, position);
    } else {
        printf("找不到 '%s'\n", pattern);
    }
    
    return 0;
}</pre>
            </div>

            <h3>3.4 Boyer-Moore 演算法（簡化版）</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define ALPHABET_SIZE 256

// 建立壞字元表
void badCharHeuristic(const char *pattern, int size, int badchar[ALPHABET_SIZE]) {
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        badchar[i] = -1;
    }
    
    for (int i = 0; i < size; i++) {
        badchar[(unsigned char)pattern[i]] = i;
    }
}

// Boyer-Moore 搜尋
int boyerMooreSearch(const char *text, const char *pattern) {
    int textLen = strlen(text);
    int patternLen = strlen(pattern);
    
    int badchar[ALPHABET_SIZE];
    badCharHeuristic(pattern, patternLen, badchar);
    
    int shift = 0;
    while (shift <= (textLen - patternLen)) {
        int j = patternLen - 1;
        
        while (j >= 0 && pattern[j] == text[shift + j]) {
            j--;
        }
        
        if (j < 0) {
            return shift;  // 找到
        } else {
            int bad = badchar[(unsigned char)text[shift + j]];
            shift += (j - bad > 1) ? j - bad : 1;
        }
    }
    
    return -1;  // 找不到
}

int main() {
    const char *text = "ABAAABCDAABAAABCDAABAAABCD";
    const char *pattern = "AABAAABCD";
    
    int position = boyerMooreSearch(text, pattern);
    
    if (position != -1) {
        printf("Boyer-Moore 找到 '%s' 在位置：%d\n", pattern, position);
    } else {
        printf("找不到 '%s'\n", pattern);
    }
    
    return 0;
}</pre>
            </div>
        </div>

        <div class="content">
            <h2>4. 字串轉換</h2>
            
            <h3>4.1 數字與字串轉換</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

// 字串轉整數（安全版本）
int safeStringToInt(const char *str, int *result) {
    char *endptr;
    long val;
    
    errno = 0;
    val = strtol(str, &endptr, 10);
    
    // 錯誤檢查
    if (errno != 0) {
        perror("strtol");
        return 0;
    }
    
    if (endptr == str) {
        fprintf(stderr, "沒有數字被轉換\n");
        return 0;
    }
    
    if (*endptr != '\0') {
        fprintf(stderr, "字串包含非數字字元：%s\n", endptr);
        return 0;
    }
    
    *result = (int)val;
    return 1;
}

// 整數轉字串
void intToString(int num, char *str, int base) {
    sprintf(str, "%d", num);
}

// 浮點數轉字串（指定小數位數）
void doubleToString(double num, char *str, int precision) {
    sprintf(str, "%.*f", precision, num);
}

// 字串轉浮點數（安全版本）
int safeStringToDouble(const char *str, double *result) {
    char *endptr;
    
    errno = 0;
    *result = strtod(str, &endptr);
    
    if (errno != 0) {
        perror("strtod");
        return 0;
    }
    
    if (endptr == str) {
        fprintf(stderr, "沒有數字被轉換\n");
        return 0;
    }
    
    return 1;
}

int main() {
    // 字串轉整數
    int num;
    if (safeStringToInt("12345", &num)) {
        printf("轉換成功：%d\n", num);
    }
    
    if (!safeStringToInt("123abc", &num)) {
        printf("轉換失敗\n");
    }
    
    // 整數轉字串
    char str[50];
    intToString(42, str, 10);
    printf("整數轉字串：%s\n", str);
    
    // 浮點數轉字串
    doubleToString(3.14159, str, 2);
    printf("浮點數轉字串（2位小數）：%s\n", str);
    
    // 字串轉浮點數
    double d;
    if (safeStringToDouble("3.14159", &d)) {
        printf("轉換成功：%f\n", d);
    }
    
    return 0;
}</pre>
            </div>

            <h3>4.2 進制轉換</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// 十進制轉任意進制（2-36）
void decimalToBase(int num, int base, char *result) {
    if (base < 2 || base > 36) {
        strcpy(result, "Invalid base");
        return;
    }
    
    if (num == 0) {
        strcpy(result, "0");
        return;
    }
    
    char digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    char temp[100];
    int i = 0;
    int isNegative = 0;
    
    if (num < 0) {
        isNegative = 1;
        num = -num;
    }
    
    while (num > 0) {
        temp[i++] = digits[num % base];
        num /= base;
    }
    
    int j = 0;
    if (isNegative) {
        result[j++] = '-';
    }
    
    while (i > 0) {
        result[j++] = temp[--i];
    }
    result[j] = '\0';
}

// 任意進制轉十進制
int baseToDecimal(const char *str, int base) {
    int result = 0;
    int sign = 1;
    int i = 0;
    
    if (str[0] == '-') {
        sign = -1;
        i = 1;
    }
    
    while (str[i]) {
        char c = str[i];
        int digit;
        
        if (c >= '0' && c <= '9') {
            digit = c - '0';
        } else if (c >= 'A' && c <= 'Z') {
            digit = c - 'A' + 10;
        } else if (c >= 'a' && c <= 'z') {
            digit = c - 'a' + 10;
        } else {
            return 0;
        }
        
        if (digit >= base) {
            return 0;
        }
        
        result = result * base + digit;
        i++;
    }
    
    return result * sign;
}

int main() {
    char result[100];
    
    // 十進制轉二進制
    decimalToBase(42, 2, result);
    printf("42 的二進制：%s\n", result);
    
    // 十進制轉十六進制
    decimalToBase(255, 16, result);
    printf("255 的十六進制：%s\n", result);
    
    // 二進制轉十進制
    int decimal = baseToDecimal("101010", 2);
    printf("101010(2) 的十進制：%d\n", decimal);
    
    // 十六進制轉十進制
    decimal = baseToDecimal("FF", 16);
    printf("FF(16) 的十進制：%d\n", decimal);
    
    return 0;
}</pre>
            </div>
        </div>

        <div class="content">
            <h2>5. 正規表示法基礎</h2>
            
            <h3>5.1 簡單模式匹配</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

// 簡單的萬用字元匹配（支援 * 和 ?）
int wildcardMatch(const char *pattern, const char *text) {
    if (*pattern == '\0' && *text == '\0') {
        return 1;
    }
    
    if (*pattern == '*') {
        // * 可以匹配零個或多個字元
        while (*text) {
            if (wildcardMatch(pattern + 1, text)) {
                return 1;
            }
            text++;
        }
        return wildcardMatch(pattern + 1, text);
    }
    
    if (*pattern == '?' || *pattern == *text) {
        // ? 匹配單一字元，或字元相同
        return wildcardMatch(pattern + 1, text + 1);
    }
    
    return 0;
}

// 檢查是否匹配指定模式
int matchPattern(const char *text, const char *pattern) {
    return wildcardMatch(pattern, text);
}

int main() {
    printf("萬用字元匹配測試：\n");
    
    printf("'hello' 匹配 'h*o': %s\n", 
           matchPattern("hello", "h*o") ? "是" : "否");
    
    printf("'hello' 匹配 'h?llo': %s\n", 
           matchPattern("hello", "h?llo") ? "是" : "否");
    
    printf("'hello' 匹配 'h*': %s\n", 
           matchPattern("hello", "h*") ? "是" : "否");
    
    printf("'hello' 匹配 'world': %s\n", 
           matchPattern("hello", "world") ? "是" : "否");
    
    return 0;
}</pre>
            </div>

            <h3>5.2 使用 POSIX 正規表示法</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;regex.h&gt;
#include &lt;string.h&gt;

// 檢查字串是否匹配正規表示法
int regexMatch(const char *pattern, const char *text) {
    regex_t regex;
    int result;
    
    // 編譯正規表示法
    result = regcomp(&regex, pattern, REG_EXTENDED);
    if (result) {
        fprintf(stderr, "無法編譯正規表示法\n");
        return 0;
    }
    
    // 執行匹配
    result = regexec(&regex, text, 0, NULL, 0);
    
    // 釋放資源
    regfree(&regex);
    
    return !result;
}

// 提取匹配的子字串
void regexExtract(const char *pattern, const char *text) {
    regex_t regex;
    regmatch_t matches[10];
    int result;
    
    result = regcomp(&regex, pattern, REG_EXTENDED);
    if (result) {
        fprintf(stderr, "無法編譯正規表示法\n");
        return;
    }
    
    result = regexec(&regex, text, 10, matches, 0);
    if (!result) {
        printf("找到匹配：\n");
        for (int i = 0; i < 10 && matches[i].rm_so != -1; i++) {
            int start = matches[i].rm_so;
            int end = matches[i].rm_eo;
            int len = end - start;
            
            printf("  匹配 %d: ", i);
            for (int j = 0; j < len; j++) {
                printf("%c", text[start + j]);
            }
            printf("\n");
        }
    } else {
        printf("沒有找到匹配\n");
    }
    
    regfree(&regex);
}

int main() {
    // 驗證電子郵件
    const char *emailPattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
    
    printf("電子郵件驗證：\n");
    printf("  test@example.com: %s\n", 
           regexMatch(emailPattern, "test@example.com") ? "有效" : "無效");
    printf("  invalid.email: %s\n", 
           regexMatch(emailPattern, "invalid.email") ? "有效" : "無效");
    
    // 驗證手機號碼
    const char *phonePattern = "^09[0-9]{2}-[0-9]{6}$";
    
    printf("\n手機號碼驗證：\n");
    printf("  0912-345678: %s\n", 
           regexMatch(phonePattern, "0912-345678") ? "有效" : "無效");
    printf("  0812-345678: %s\n", 
           regexMatch(phonePattern, "0812-345678") ? "有效" : "無效");
    
    // 提取數字
    printf("\n提取數字：\n");
    regexExtract("[0-9]+", "The price is 100 dollars and 50 cents");
    
    return 0;
}</pre>
            </div>
        </div>

        <div class="content">
            <h2>6. 字串緩衝區與建構器</h2>
            
            <h3>6.1 動態字串緩衝區</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct {
    char *data;
    size_t length;
    size_t capacity;
} StringBuilder;

// 初始化字串建構器
StringBuilder* sbCreate(size_t initialCapacity) {
    StringBuilder *sb = (StringBuilder*)malloc(sizeof(StringBuilder));
    sb->data = (char*)malloc(initialCapacity);
    sb->data[0] = '\0';
    sb->length = 0;
    sb->capacity = initialCapacity;
    return sb;
}

// 附加字串
void sbAppend(StringBuilder *sb, const char *str) {
    size_t len = strlen(str);
    
    // 需要擴充容量
    while (sb->length + len + 1 > sb->capacity) {
        sb->capacity *= 2;
        sb->data = (char*)realloc(sb->data, sb->capacity);
    }
    
    strcpy(sb->data + sb->length, str);
    sb->length += len;
}

// 附加字元
void sbAppendChar(StringBuilder *sb, char c) {
    if (sb->length + 2 > sb->capacity) {
        sb->capacity *= 2;
        sb->data = (char*)realloc(sb->data, sb->capacity);
    }
    
    sb->data[sb->length++] = c;
    sb->data[sb->length] = '\0';
}

// 附加整數
void sbAppendInt(StringBuilder *sb, int num) {
    char buffer[32];
    sprintf(buffer, "%d", num);
    sbAppend(sb, buffer);
}

// 清空內容
void sbClear(StringBuilder *sb) {
    sb->length = 0;
    sb->data[0] = '\0';
}

// 取得字串
const char* sbToString(StringBuilder *sb) {
    return sb->data;
}

// 釋放記憶體
void sbDestroy(StringBuilder *sb) {
    free(sb->data);
    free(sb);
}

int main() {
    StringBuilder *sb = sbCreate(16);
    
    sbAppend(sb, "Hello");
    sbAppendChar(sb, ' ');
    sbAppend(sb, "World");
    sbAppendChar(sb, '!');
    
    printf("字串：%s\n", sbToString(sb));
    printf("長度：%zu, 容量：%zu\n", sb->length, sb->capacity);
    
    sbClear(sb);
    
    // 建構複雜字串
    for (int i = 1; i <= 5; i++) {
        sbAppend(sb, "Number ");
        sbAppendInt(sb, i);
        sbAppend(sb, ", ");
    }
    
    printf("\n新字串：%s\n", sbToString(sb));
    printf("長度：%zu, 容量：%zu\n", sb->length, sb->capacity);
    
    sbDestroy(sb);
    
    return 0;
}</pre>
            </div>
        </div>

        <div class="content">
            <h2>7. 實務應用範例</h2>
            
            <h3>7.1 文字處理工具</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

// 字數統計
void wordCount(const char *text) {
    int chars = 0, words = 0, lines = 0;
    int inWord = 0;
    
    for (int i = 0; text[i] != '\0'; i++) {
        chars++;
        
        if (text[i] == '\n') {
            lines++;
        }
        
        if (isspace(text[i])) {
            inWord = 0;
        } else if (!inWord) {
            inWord = 1;
            words++;
        }
    }
    
    printf("統計結果：\n");
    printf("  字元數：%d\n", chars);
    printf("  字數：%d\n", words);
    printf("  行數：%d\n", lines);
}

// 尋找並取代
void findAndReplace(char *text, const char *find, const char *replace) {
    char buffer[1000];
    char *pos;
    int findLen = strlen(find);
    int replaceLen = strlen(replace);
    
    buffer[0] = '\0';
    char *start = text;
    
    while ((pos = strstr(start, find)) != NULL) {
        // 複製到找到的位置之前的內容
        strncat(buffer, start, pos - start);
        // 加入替換字串
        strcat(buffer, replace);
        // 移動到找到位置之後
        start = pos + findLen;
    }
    
    // 複製剩餘內容
    strcat(buffer, start);
    strcpy(text, buffer);
}

int main() {
    char text[] = "Hello World\nThis is a test\nHello C Programming";
    
    printf("原始文字：\n%s\n\n", text);
    
    wordCount(text);
    
    printf("\n尋找並取代 'Hello' 為 'Hi'：\n");
    findAndReplace(text, "Hello", "Hi");
    printf("%s\n", text);
    
    return 0;
}</pre>
            </div>

            <h3>7.2 URL 解析器</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    char protocol[20];
    char host[100];
    int port;
    char path[200];
    char query[200];
} URL;

// 解析 URL
int parseURL(const char *urlStr, URL *url) {
    char *ptr = (char*)urlStr;
    
    // 解析協定
    char *colonSlash = strstr(ptr, "://");
    if (colonSlash) {
        int len = colonSlash - ptr;
        strncpy(url->protocol, ptr, len);
        url->protocol[len] = '\0';
        ptr = colonSlash + 3;
    } else {
        strcpy(url->protocol, "http");
    }
    
    // 解析主機和端口
    char *slash = strchr(ptr, '/');
    char *colon = strchr(ptr, ':');
    
    if (colon && (!slash || colon < slash)) {
        // 有指定端口
        int len = colon - ptr;
        strncpy(url->host, ptr, len);
        url->host[len] = '\0';
        
        url->port = atoi(colon + 1);
        
        if (slash) {
            ptr = slash;
        } else {
            url->path[0] = '\0';
            url->query[0] = '\0';
            return 1;
        }
    } else {
        // 沒有指定端口，使用預設
        url->port = strcmp(url->protocol, "https") == 0 ? 443 : 80;
        
        if (slash) {
            int len = slash - ptr;
            strncpy(url->host, ptr, len);
            url->host[len] = '\0';
            ptr = slash;
        } else {
            strcpy(url->host, ptr);
            url->path[0] = '\0';
            url->query[0] = '\0';
            return 1;
        }
    }
    
    // 解析路徑和查詢字串
    char *question = strchr(ptr, '?');
    if (question) {
        int len = question - ptr;
        strncpy(url->path, ptr, len);
        url->path[len] = '\0';
        strcpy(url->query, question + 1);
    } else {
        strcpy(url->path, ptr);
        url->query[0] = '\0';
    }
    
    return 1;
}

int main() {
    URL url;
    
    const char *testURLs[] = {
        "https://www.example.com:8080/path/to/page?key=value&foo=bar",
        "http://example.com/index.html",
        "ftp://files.example.com:21/download/file.txt"
    };
    
    for (int i = 0; i < 3; i++) {
        printf("解析 URL: %s\n", testURLs[i]);
        
        if (parseURL(testURLs[i], &url)) {
            printf("  協定：%s\n", url.protocol);
            printf("  主機：%s\n", url.host);
            printf("  端口：%d\n", url.port);
            printf("  路徑：%s\n", url.path);
            printf("  查詢：%s\n", url.query);
        }
        printf("\n");
    }
    
    return 0;
}</pre>
            </div>

            <h3>7.3 JSON 簡單解析器</h3>
            <div class="code-block">
<pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

// 簡化的 JSON 值提取（僅支援簡單的鍵值對）
char* getJSONValue(const char *json, const char *key) {
    static char value[200];
    char searchKey[100];
    
    // 建立搜尋模式："key":
    sprintf(searchKey, "\"%s\"", key);
    
    char *pos = strstr(json, searchKey);
    if (!pos) {
        return NULL;
    }
    
    // 跳過鍵和冒號
    pos += strlen(searchKey);
    while (*pos && (*pos == ':' || isspace(*pos))) {
        pos++;
    }
    
    // 提取值
    if (*pos == '"') {
        // 字串值
        pos++;
        char *end = strchr(pos, '"');
        if (end) {
            int len = end - pos;
            strncpy(value, pos, len);
            value[len] = '\0';
            return value;
        }
    } else {
        // 數字或布林值
        char *end = pos;
        while (*end && *end != ',' && *end != '}' && !isspace(*end)) {
            end++;
        }
        int len = end - pos;
        strncpy(value, pos, len);
        value[len] = '\0';
        return value;
    }
    
    return NULL;
}

int main() {
    const char *json = "{\"name\":\"John Doe\",\"age\":30,\"city\":\"Taipei\",\"active\":true}";
    
    printf("JSON 字串：\n%s\n\n", json);
    
    printf("解析結果：\n");
    printf("  name: %s\n", getJSONValue(json, "name"));
    printf("  age: %s\n", getJSONValue(json, "age"));
    printf("  city: %s\n", getJSONValue(json, "city"));
    printf("  active: %s\n", getJSONValue(json, "active"));
    
    return 0;
}</pre>
            </div>
        </div>

        <div class="content">
            <div class="exercise-section">
                <h3>本週練習題</h3>
                
                <h4>基礎練習</h4>
                <ol>
                    <li><strong>字串工具函數庫</strong>
                        <br>實作常用的字串處理函數：
                        <ul>
                            <li>反轉字串</li>
                            <li>移除重複字元</li>
                            <li>檢查是否為回文</li>
                            <li>計算子字串出現次數</li>
                        </ul>
                    </li>
                    <li><strong>格式驗證器</strong>
                        <br>建立各種格式驗證函數：
                        <ul>
                            <li>信用卡號碼驗證</li>
                            <li>IP 位址驗證</li>
                            <li>日期格式驗證</li>
                            <li>URL 格式驗證</li>
                        </ul>
                    </li>
                    <li><strong>CSV 處理器</strong>
                        <br>實作 CSV 檔案讀寫：
                        <ul>
                            <li>解析 CSV 行</li>
                            <li>處理引號內的逗號</li>
                            <li>匯出資料為 CSV</li>
                        </ul>
                    </li>
                </ol>

                <h4>進階練習</h4>
                <ol start="4">
                    <li><strong>文字編輯器功能</strong>
                        <br>實作文字編輯功能：
                        <ul>
                            <li>尋找並取代（支援大小寫忽略）</li>
                            <li>自動縮排</li>
                            <li>語法高亮標記</li>
                            <li>字數和行數統計</li>
                        </ul>
                    </li>
                    <li><strong>命令列解析器</strong>
                        <br>解析命令列參數：
                        <ul>
                            <li>支援短參數（-h）和長參數（--help）</li>
                            <li>參數值處理</li>
                            <li>自動生成說明文件</li>
                        </ul>
                    </li>
                    <li><strong>模板引擎</strong>
                        <br>簡易模板系統：
                        <ul>
                            <li>變數替換（{{variable}}）</li>
                            <li>條件判斷</li>
                            <li>迴圈處理</li>
                        </ul>
                    </li>
                </ol>

                <h4>挑戰題</h4>
                <ol start="7">
                    <li><strong>Markdown 解析器</strong>
                        <br>將 Markdown 轉換為 HTML：
                        <ul>
                            <li>標題、粗體、斜體</li>
                            <li>列表（有序、無序）</li>
                            <li>連結和圖片</li>
                            <li>程式碼區塊</li>
                        </ul>
                    </li>
                    <li><strong>運算式求值器</strong>
                        <br>解析並計算數學運算式：
                        <ul>
                            <li>支援四則運算和括號</li>
                            <li>運算子優先順序</li>
                            <li>函數支援（sin, cos, sqrt等）</li>
                            <li>變數定義</li>
                        </ul>
                    </li>
                    <li><strong>日誌分析工具</strong>
                        <br>分析伺服器日誌：
                        <ul>
                            <li>解析不同格式日誌</li>
                            <li>統計請求數量</li>
                            <li>錯誤分析</li>
                            <li>產生報表</li>
                        </ul>
                    </li>
                </ol>
            </div>
        </div>

        <div class="content">
            <h2>本週總結</h2>
            <div class="tip-box">
                <strong>重點回顧：</strong>
                <ul>
                    <li>掌握字串分割與解析技巧</li>
                    <li>了解字串格式化與驗證方法</li>
                    <li>熟悉各種字串搜尋演算法</li>
                    <li>學會字串與數字的轉換</li>
                    <li>理解正規表示法基礎</li>
                    <li>能夠建立動態字串緩衝區</li>
                    <li>實作實用的字串處理工具</li>
                </ul>
            </div>

            <div class="warning-box">
                <strong>重要提醒：</strong>
                <ul>
                    <li>使用 strtok() 時注意會修改原字串</li>
                    <li>字串操作要檢查緩衝區大小</li>
                    <li>數字轉換要進行錯誤檢查</li>
                    <li>注意字串結尾的 null 字元</li>
                    <li>動態配置記憶體要記得釋放</li>
                </ul>
            </div>

            <div class="note-box">
                <strong>下週預告：</strong>
                <p>Week 12 將學習「資料結構實作」，包含：</p>
                <ul>
                    <li>鏈結串列（Linked List）實作</li>
                    <li>堆疊（Stack）與佇列（Queue）</li>
                    <li>二元樹（Binary Tree）基礎</li>
                    <li>雜湊表（Hash Table）實作</li>
                    <li>資料結構的應用與比較</li>
                </ul>
            </div>
        </div>

        <div class="nav-buttons">
            <a href="week10.html" class="btn btn-secondary">← Week 10</a>
            <a href="week12.html" class="btn">Week 12 →</a>
        </div>
    </div>
</body>
</html>